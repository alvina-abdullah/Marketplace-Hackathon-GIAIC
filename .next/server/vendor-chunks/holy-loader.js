"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/holy-loader";
exports.ids = ["vendor-chunks/holy-loader"];
exports.modules = {

/***/ "(ssr)/./node_modules/holy-loader/dist/index.js":
/*!************************************************!*\
  !*** ./node_modules/holy-loader/dist/index.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ src_default),\n/* harmony export */   startHolyLoader: () => (/* binding */ startHolyLoader),\n/* harmony export */   stopHolyLoader: () => (/* binding */ stopHolyLoader)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* __next_internal_client_entry_do_not_use__ default,startHolyLoader,stopHolyLoader auto */ var __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value)=>key in obj ? __defProp(obj, key, {\n        enumerable: true,\n        configurable: true,\n        writable: true,\n        value\n    }) : obj[key] = value;\nvar __spreadValues = (a, b)=>{\n    for(var prop in b || (b = {}))if (__hasOwnProp.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n    if (__getOwnPropSymbols) for (var prop of __getOwnPropSymbols(b)){\n        if (__propIsEnum.call(b, prop)) __defNormalProp(a, prop, b[prop]);\n    }\n    return a;\n};\nvar __name = (target, value)=>__defProp(target, \"name\", {\n        value,\n        configurable: true\n    });\n// src/index.tsx\n\n// src/constants.ts\nvar DEFAULTS = {\n    color: \"#59a2ff\",\n    initialPosition: 0.08,\n    height: 4,\n    easing: \"ease\",\n    speed: 200,\n    zIndex: 2147483647,\n    showSpinner: false,\n    boxShadow: void 0,\n    ignoreSearchParams: false,\n    dir: \"ltr\"\n};\nvar START_HOLY_EVENT = \"holy-progress-start\";\nvar STOP_HOLY_EVENT = \"holy-progress-stop\";\n// src/utils.ts\nvar toAbsoluteURL = /* @__PURE__ */ __name((url)=>{\n    return new URL(url, window.location.href).href;\n}, \"toAbsoluteURL\");\nvar isSamePageAnchor = /* @__PURE__ */ __name((currentUrl, newUrl)=>{\n    const current = new URL(toAbsoluteURL(currentUrl));\n    const next = new URL(toAbsoluteURL(newUrl));\n    return current.href.split(\"#\")[0] === next.href.split(\"#\")[0];\n}, \"isSamePageAnchor\");\nvar isSameHost = /* @__PURE__ */ __name((currentUrl, newUrl)=>{\n    const current = new URL(toAbsoluteURL(currentUrl));\n    const next = new URL(toAbsoluteURL(newUrl));\n    return current.hostname.replace(/^www\\./, \"\") === next.hostname.replace(/^www\\./, \"\");\n}, \"isSameHost\");\nvar paramsAreEqual = /* @__PURE__ */ __name((params1, params2)=>Array.from(params1).every(([key, value])=>params2.has(key) && params2.get(key) === value), \"paramsAreEqual\");\nvar hasSameQueryParameters = /* @__PURE__ */ __name((currentUrl, newUrl)=>{\n    const current = new URL(toAbsoluteURL(currentUrl));\n    const next = newUrl instanceof URL ? newUrl : new URL(toAbsoluteURL(newUrl));\n    const currentParams = new URLSearchParams(current.search);\n    const nextParams = new URLSearchParams(next.search);\n    return paramsAreEqual(currentParams, nextParams) && paramsAreEqual(nextParams, currentParams);\n}, \"hasSameQueryParameters\");\nvar isSamePathname = /* @__PURE__ */ __name((currentUrl, newUrl)=>{\n    const current = new URL(toAbsoluteURL(currentUrl));\n    const next = newUrl instanceof URL ? newUrl : new URL(toAbsoluteURL(newUrl));\n    return current.pathname === next.pathname;\n}, \"isSamePathname\");\nvar clamp = /* @__PURE__ */ __name((n, min, max)=>Math.max(min, Math.min(n, max)), \"clamp\");\nvar queue = /* @__PURE__ */ (()=>{\n    const pending = [];\n    const next = /* @__PURE__ */ __name(()=>{\n        const fn = pending.shift();\n        if (fn !== void 0) {\n            fn(next);\n        }\n    }, \"next\");\n    return (fn)=>{\n        pending.push(fn);\n        if (pending.length === 1) {\n            next();\n        }\n    };\n})();\nvar repaintElement = /* @__PURE__ */ __name((obj)=>{\n    void obj.offsetWidth;\n    return obj;\n}, \"repaintElement\");\n// src/HolyProgress.ts\nvar _HolyProgress = class _HolyProgress {\n    /**\n   * Create a HolyProgress instance.\n   * @param {Partial<HolyProgressProps>} [customSettings] - Optional custom settings to override defaults.\n   */ constructor(customSettings){\n        /**\n     * Sets the progress to a specific value.\n     * @private\n     * @param {number} n - The new progress value (0 to 1).\n     * @returns {HolyProgress} The current instance for chaining methods.\n     */ this.setTo = /* @__PURE__ */ __name((n)=>{\n            const isStarted = typeof this.progressN === \"number\";\n            n = clamp(n, this.settings.initialPosition, 1);\n            this.progressN = n === 1 ? null : n;\n            const progressBar = this.getOrCreateBar(!isStarted);\n            if (!progressBar) {\n                return this;\n            }\n            repaintElement(progressBar);\n            queue((next)=>{\n                if (!this.bar) {\n                    return;\n                }\n                Object.assign(this.bar.style, this.barPositionCSS(n), {\n                    transition: `all ${this.settings.speed}ms ${this.settings.easing}`\n                });\n                if (n === 1) {\n                    progressBar.style.transition = \"none\";\n                    progressBar.style.opacity = \"1\";\n                    repaintElement(progressBar);\n                    setTimeout(()=>{\n                        progressBar.style.transition = `all ${this.settings.speed}ms linear`;\n                        progressBar.style.opacity = \"0\";\n                        setTimeout(()=>{\n                            this.removeBarFromDOM();\n                            next();\n                        }, this.settings.speed);\n                        this.removeSpinnerFromDOM();\n                    }, this.settings.speed);\n                } else {\n                    setTimeout(next, this.settings.speed);\n                }\n            });\n            return this;\n        }, \"setTo\");\n        /**\n     * Converts a progress value (0 to 1) into a percentage representation.\n     * Used for calculating the visual width of the progress bar.\n     * @private\n     * @param {number} n - The progress value to convert.\n     * @returns {number} The percentage representation of the progress value.\n     */ this.toBarPercentage = /* @__PURE__ */ __name((n)=>this.settings.dir === \"ltr\" ? (-1 + n) * 100 : (1 - n) * 100, \"toBarPercentage\");\n        /**\n     * Initiates the progress bar's movement. If already started, it continues from the current position.\n     * Automatically handles automatic incrementation ('trickle') if enabled.\n     * @public\n     * @returns {HolyProgress} The current instance for chaining methods.\n     */ this.start = /* @__PURE__ */ __name(()=>{\n            if (this.progressN === null) {\n                this.setTo(0);\n                this.startTrickle();\n                if (this.settings.showSpinner === true) {\n                    this.createSpinner();\n                }\n            }\n            return this;\n        }, \"start\");\n        /**\n     * Performs automatic incrementation of the progress bar.\n     * This function is recursive and continues to increment the progress at intervals defined by `speed`.\n     * @private\n     */ this.startTrickle = /* @__PURE__ */ __name(()=>{\n            const run = /* @__PURE__ */ __name(()=>{\n                if (this.progressN === null) return;\n                this.incrementStatus();\n                setTimeout(run, this.settings.speed);\n            }, \"run\");\n            setTimeout(run, this.settings.speed);\n        }, \"startTrickle\");\n        /**\n     * Completes the progress, moving it to 100%\n     * @public\n     * @returns {HolyProgress} The current instance for chaining methods.\n     */ this.complete = /* @__PURE__ */ __name(()=>this.setTo(1), \"complete\");\n        /**\n     * Calculates an increment value based on the current status of the progress.\n     * This is used to determine the amount of progress to add during automatic incrementation.\n     * @private\n     * @param {number} status - The current progress status.\n     * @returns {number} The calculated increment value.\n     */ this.calculateIncrement = /* @__PURE__ */ __name((status)=>{\n            const base = 0.1;\n            const scale = 5;\n            return base * Math.exp(-scale * status);\n        }, \"calculateIncrement\");\n        /**\n     * Increments the progress bar by a specified amount, or by an amount determined by `calculateIncrement` if not specified.\n     * @private\n     * @param {number} [amount] - The amount to increment the progress bar.\n     * @returns {HolyProgress} The current instance for chaining methods.\n     */ this.incrementStatus = /* @__PURE__ */ __name((amount)=>{\n            if (this.progressN === null) {\n                return this.start();\n            }\n            if (this.progressN > 1) {\n                return this;\n            }\n            if (typeof amount !== \"number\") {\n                amount = this.calculateIncrement(this.progressN);\n            }\n            this.progressN = clamp(this.progressN + amount, 0, 0.994);\n            return this.setTo(this.progressN);\n        }, \"incrementStatus\");\n        /**\n     * Creates and initializes a new progress bar element in the DOM.\n     * It sets up the necessary styles and appends the element to the document body.\n     * @private\n     * @param {boolean} fromStart - Indicates if the bar is created from the start position.\n     * @returns {HTMLElement | null} The created progress bar element, or null if creation fails.\n     */ this.createBar = /* @__PURE__ */ __name((fromStart)=>{\n            var _a, _b;\n            const barContainer = document.createElement(\"div\");\n            barContainer.id = \"holy-progress\";\n            barContainer.style.pointerEvents = \"none\";\n            barContainer.innerHTML = '<div class=\"bar\" role=\"bar\"></div>';\n            this.bar = barContainer.querySelector('[role=\"bar\"]');\n            if (!this.bar) {\n                return null;\n            }\n            const percentage = this.toBarPercentage(fromStart ? 0 : (_a = this.progressN) != null ? _a : 0);\n            this.bar.style.background = this.settings.color;\n            if (typeof this.settings.height === \"number\") {\n                this.bar.style.height = `${this.settings.height}px`;\n            } else {\n                this.bar.style.height = this.settings.height;\n            }\n            this.bar.style.zIndex = this.settings.zIndex.toString();\n            this.bar.style.position = \"fixed\";\n            this.bar.style.width = \"100%\";\n            this.bar.style.top = \"0\";\n            this.bar.style.left = \"0\";\n            this.bar.style.transition = \"all 0 linear\";\n            this.bar.style.transform = `translate3d(${percentage}%,0,0)`;\n            this.bar.style.boxShadow = (_b = this.settings.boxShadow) != null ? _b : \"\";\n            document.body.appendChild(barContainer);\n            return barContainer;\n        }, \"createBar\");\n        /**\n     * Creates and initializes a new spinner element in the DOM.\n     * It sets up the necessary styles and appends the element to the document body.\n     * @private\n     * @returns {void}\n     */ this.createSpinner = /* @__PURE__ */ __name(()=>{\n            if (document.getElementById(\"holy-progress-spinner\") !== null) {\n                return;\n            }\n            const spinner = document.createElement(\"div\");\n            spinner.id = \"holy-progress-spinner\";\n            spinner.style.pointerEvents = \"none\";\n            spinner.style.display = \"block\";\n            spinner.style.position = \"fixed\";\n            spinner.style.zIndex = this.settings.zIndex.toString();\n            spinner.style.top = \"15px\";\n            spinner.style.right = \"15px\";\n            spinner.style.width = \"18px\";\n            spinner.style.height = \"18px\";\n            spinner.style.boxSizing = \"border-box\";\n            spinner.style.border = \"solid 2px transparent\";\n            spinner.style.borderTopColor = this.settings.color;\n            spinner.style.borderLeftColor = this.settings.color;\n            spinner.style.borderRadius = \"50%\";\n            spinner.style.animation = \"holy-progress-spinner 400ms linear infinite\";\n            const keyframes = `\n      @keyframes holy-progress-spinner {\n        0%   { transform: rotate(0deg); }\n        100% { transform: rotate(360deg); }\n      }\n    `;\n            const style = document.createElement(\"style\");\n            style.innerHTML = keyframes;\n            spinner.appendChild(style);\n            document.body.appendChild(spinner);\n        }, \"createSpinner\");\n        this.getOrCreateBar = /* @__PURE__ */ __name((fromStart)=>{\n            var _a;\n            return (_a = document.getElementById(\"holy-progress\")) != null ? _a : this.createBar(fromStart);\n        }, \"getOrCreateBar\");\n        this.removeBarFromDOM = /* @__PURE__ */ __name(()=>{\n            var _a;\n            return (_a = document.getElementById(\"holy-progress\")) == null ? void 0 : _a.remove();\n        }, \"removeBarFromDOM\");\n        this.removeSpinnerFromDOM = /* @__PURE__ */ __name(()=>{\n            var _a;\n            return (_a = document.getElementById(\"holy-progress-spinner\")) == null ? void 0 : _a.remove();\n        }, \"removeSpinnerFromDOM\");\n        /**\n     * Determines the most suitable CSS positioning strategy based on browser capabilities.\n     * Checks for transform properties with vendor prefixes and standard un-prefixed properties.\n     * @private\n     * @returns {TransformStrategy} - The optimal CSS positioning strategy ('translate3d', 'translate', or 'margin').\n     */ this.getTransformStrategy = /* @__PURE__ */ __name(()=>{\n            const style = document.body.style;\n            const prefixes = [\n                \"Webkit\",\n                \"Moz\",\n                \"ms\",\n                \"O\",\n                \"\"\n            ];\n            let transformProp = \"\";\n            for(let i = 0; i < prefixes.length; i++){\n                if (`${prefixes[i]}Transform` in style) {\n                    transformProp = prefixes[i];\n                    break;\n                }\n            }\n            if (transformProp !== \"\" && `${transformProp}Perspective` in style) {\n                return \"translate3d\";\n            }\n            if (transformProp !== \"\") {\n                return \"translate\";\n            }\n            return \"margin\";\n        }, \"getTransformStrategy\");\n        /**\n     * Generates the CSS for the progress bar position based on the detected positioning strategy.\n     * Dynamically sets the transform or margin-left properties for the bar's position.\n     * @private\n     * @param {number} n - Position value of the bar, as a number between 0 and 1.\n     * @returns {Object} - CSS styles for the progress bar.\n     */ this.barPositionCSS = /* @__PURE__ */ __name((n)=>{\n            const transformStrategy = this.getTransformStrategy();\n            const barPosition = `${this.toBarPercentage(n)}%`;\n            if (transformStrategy === \"translate3d\") {\n                return {\n                    transform: `translate3d(${barPosition},0,0)`\n                };\n            }\n            if (transformStrategy === \"translate\") {\n                return {\n                    transform: `translate(${barPosition},0)`\n                };\n            }\n            return {\n                marginLeft: barPosition\n            };\n        }, \"barPositionCSS\");\n        this.settings = __spreadValues(__spreadValues({}, DEFAULTS), customSettings);\n        this.progressN = null;\n        this.bar = null;\n    }\n};\n__name(_HolyProgress, \"HolyProgress\");\nvar HolyProgress = _HolyProgress;\n// src/index.tsx\nvar startHolyLoader = /* @__PURE__ */ __name(()=>{\n    document.dispatchEvent(new Event(START_HOLY_EVENT));\n}, \"startHolyLoader\");\nvar stopHolyLoader = /* @__PURE__ */ __name(()=>{\n    document.dispatchEvent(new Event(STOP_HOLY_EVENT));\n}, \"stopHolyLoader\");\nvar HolyLoader = /* @__PURE__ */ __name(({ color = DEFAULTS.color, initialPosition = DEFAULTS.initialPosition, height = DEFAULTS.height, easing = DEFAULTS.easing, speed = DEFAULTS.speed, zIndex = DEFAULTS.zIndex, boxShadow = DEFAULTS.boxShadow, showSpinner = DEFAULTS.showSpinner, ignoreSearchParams = DEFAULTS.ignoreSearchParams, dir = DEFAULTS.dir })=>{\n    const holyProgressRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        const startProgress = /* @__PURE__ */ __name(()=>{\n            if (holyProgressRef.current === null) {\n                return;\n            }\n            try {\n                holyProgressRef.current.start();\n            } catch (error) {}\n        }, \"startProgress\");\n        const stopProgress = /* @__PURE__ */ __name(()=>{\n            if (holyProgressRef.current === null) {\n                return;\n            }\n            try {\n                holyProgressRef.current.complete();\n            } catch (error) {}\n        }, \"stopProgress\");\n        let isHistoryPatched = false;\n        const stopProgressOnHistoryUpdate = /* @__PURE__ */ __name(()=>{\n            if (isHistoryPatched) {\n                return;\n            }\n            const originalPushState = history.pushState.bind(history);\n            history.pushState = (...args)=>{\n                const url = args[2];\n                if (url && isSamePathname(window.location.href, url) && (ignoreSearchParams || hasSameQueryParameters(window.location.href, url))) {\n                    originalPushState(...args);\n                    return;\n                }\n                stopProgress();\n                originalPushState(...args);\n            };\n            const originalReplaceState = history.replaceState.bind(history);\n            history.replaceState = (...args)=>{\n                const url = args[2];\n                if (url && isSamePathname(window.location.href, url) && (ignoreSearchParams || hasSameQueryParameters(window.location.href, url))) {\n                    originalReplaceState(...args);\n                    return;\n                }\n                stopProgress();\n                originalReplaceState(...args);\n            };\n            isHistoryPatched = true;\n        }, \"stopProgressOnHistoryUpdate\");\n        const handleClick = /* @__PURE__ */ __name((event)=>{\n            try {\n                const target = event.target;\n                const anchor = target.closest(\"a\");\n                if (anchor === null || anchor.target === \"_blank\" || anchor.hasAttribute(\"download\") || event.ctrlKey || event.metaKey || // Skip if URL points to a different domain\n                !isSameHost(window.location.href, anchor.href) || // Skip if URL is a same-page anchor (href=\"#\", href=\"#top\", etc.).\n                isSamePageAnchor(window.location.href, anchor.href) || // Skip if URL uses a non-http/https protocol (mailto:, tel:, etc.).\n                !toAbsoluteURL(anchor.href).startsWith(\"http\") || // Skip if the URL is the same as the current page\n                isSamePathname(window.location.href, anchor.href) && (ignoreSearchParams || hasSameQueryParameters(window.location.href, anchor.href))) {\n                    return;\n                }\n                startProgress();\n            } catch (error) {\n                stopProgress();\n            }\n        }, \"handleClick\");\n        try {\n            if (holyProgressRef.current === null) {\n                holyProgressRef.current = new HolyProgress({\n                    color,\n                    height,\n                    initialPosition,\n                    easing,\n                    speed,\n                    zIndex,\n                    boxShadow,\n                    showSpinner,\n                    dir\n                });\n            }\n            document.addEventListener(\"click\", handleClick);\n            document.addEventListener(START_HOLY_EVENT, startProgress);\n            document.addEventListener(STOP_HOLY_EVENT, stopProgress);\n            stopProgressOnHistoryUpdate();\n        } catch (error) {}\n        return ()=>{\n            document.removeEventListener(\"click\", handleClick);\n            document.removeEventListener(START_HOLY_EVENT, startProgress);\n            document.removeEventListener(STOP_HOLY_EVENT, stopProgress);\n        };\n    }, [\n        holyProgressRef\n    ]);\n    return null;\n}, \"HolyLoader\");\nvar src_default = HolyLoader;\n //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaG9seS1sb2FkZXIvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUV1Qjs7QUNGaEIsSUFBTUMsV0FBVztJQUN0QkMsT0FBTztJQUNQQyxpQkFBaUI7SUFDakJDLFFBQVE7SUFDUkMsUUFBUTtJQUNSQyxPQUFPO0lBQ1BDLFFBQVE7SUFDUkMsYUFBYTtJQUNiQyxXQUFXO0lBQ1hDLG9CQUFvQjtJQUNwQkMsS0FBSztBQUNQO0FBRU8sSUFBTUMsbUJBQW1CO0FBQ3pCLElBQU1DLGtCQUFrQjs7QUNQeEIsSUFBTUMsZ0JBQWdCLGdCQUFBQyxPQUFBLENBQUNDO0lBQzVCLE9BQU8sSUFBSUMsSUFBSUQsS0FBS0UsT0FBT0MsUUFBQSxDQUFTQyxJQUFJLEVBQUVBLElBQUE7QUFDNUMsR0FGNkI7QUFXdEIsSUFBTUMsbUJBQW1CLGdCQUFBTixPQUFBLENBQzlCTyxZQUNBQztJQUVBLE1BQU1DLFVBQVUsSUFBSVAsSUFBSUgsY0FBY1E7SUFDdEMsTUFBTUcsT0FBTyxJQUFJUixJQUFJSCxjQUFjUztJQUNuQyxPQUFPQyxRQUFRSixJQUFBLENBQUtNLEtBQUEsQ0FBTSxJQUFHLENBQUUsRUFBQyxLQUFNRCxLQUFLTCxJQUFBLENBQUtNLEtBQUEsQ0FBTSxJQUFHLENBQUUsRUFBQztBQUM5RCxHQVBnQztBQWdCekIsSUFBTUMsYUFBYSxnQkFBQVosT0FBQSxDQUFDTyxZQUFvQkM7SUFDN0MsTUFBTUMsVUFBVSxJQUFJUCxJQUFJSCxjQUFjUTtJQUN0QyxNQUFNRyxPQUFPLElBQUlSLElBQUlILGNBQWNTO0lBQ25DLE9BQ0VDLFFBQVFJLFFBQUEsQ0FBU0MsT0FBQSxDQUFRLFVBQVUsUUFDbkNKLEtBQUtHLFFBQUEsQ0FBU0MsT0FBQSxDQUFRLFVBQVU7QUFFcEMsR0FQMEI7QUFTMUIsSUFBTUMsaUJBQWlCLGdCQUFBZixPQUFBLENBQUNnQixTQUEwQkMsVUFDaERDLE1BQU1DLElB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VjtZQUN0Q3pELFNBQVNtRSxtQkFBQSxDQUFvQnpKLGtCQUFrQm1JO1lBQy9DN0MsU0FBU21FLG1CQUFBLENBQW9CeEosaUJBQWlCb0k7UUFDaEQ7SUFDRixHQUFHO1FBQUNMO0tBQWdCO0lBRXBCLE9BQU87QUFDVCxHQXpKbUI7QUEySm5CLElBQU8wQixjQUFRM0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LWVjb21tZXJjZS1zaG9wY28vLi4vc3JjL2luZGV4LnRzeD9kMGUwIiwid2VicGFjazovL25leHQtZWNvbW1lcmNlLXNob3Bjby8uLi9zcmMvY29uc3RhbnRzLnRzP2IxM2UiLCJ3ZWJwYWNrOi8vbmV4dC1lY29tbWVyY2Utc2hvcGNvLy4uL3NyYy91dGlscy50cz8yN2FkIiwid2VicGFjazovL25leHQtZWNvbW1lcmNlLXNob3Bjby8uLi9zcmMvSG9seVByb2dyZXNzLnRzP2ZjNTkiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnO1xuXG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBIb2x5UHJvZ3Jlc3MgfSBmcm9tICcuL0hvbHlQcm9ncmVzcyc7XG5pbXBvcnQgeyBERUZBVUxUUywgU1RBUlRfSE9MWV9FVkVOVCwgU1RPUF9IT0xZX0VWRU5UIH0gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IHtcbiAgaXNTYW1lSG9zdCxcbiAgaXNTYW1lUGFnZUFuY2hvcixcbiAgdG9BYnNvbHV0ZVVSTCxcbiAgaGFzU2FtZVF1ZXJ5UGFyYW1ldGVycyxcbiAgaXNTYW1lUGF0aG5hbWUsXG59IGZyb20gJy4vdXRpbHMnO1xuXG5leHBvcnQgaW50ZXJmYWNlIEhvbHlMb2FkZXJQcm9wcyB7XG4gIC8qKlxuICAgKiBTcGVjaWZpZXMgdGhlIGNvbG9yIG9mIHRoZSB0b3AtbG9hZGluZyBiYXIuXG4gICAqIERlZmF1bHQ6IFwiIzU5YTJmZlwiIChhIHNoYWRlIG9mIGJsdWUpXG4gICAqL1xuICBjb2xvcj86IHN0cmluZztcblxuICAvKipcbiAgICogU2V0cyB0aGUgaW5pdGlhbCBwb3NpdGlvbiBvZiB0aGUgdG9wLWxvYWRpbmcgYmFyIGFzIGEgcGVyY2VudGFnZSBvZiB0aGUgdG90YWwgd2lkdGguXG4gICAqIERlZmF1bHQ6IDAuMDggKDglIG9mIHRoZSB0b3RhbCB3aWR0aClcbiAgICovXG4gIGluaXRpYWxQb3NpdGlvbj86IG51bWJlcjtcblxuICAvKipcbiAgICogU3BlY2lmaWVzIHRoZSBoZWlnaHQgb2YgdGhlIHRvcC1sb2FkaW5nIGJhciBpbiBlaXRoZXIgcGl4ZWxzIChudW1iZXIpIG9yIGNzcyB1bml0IChzdHJpbmcpLlxuICAgKiBEZWZhdWx0OiA0IHBpeGVsc1xuICAgKi9cbiAgaGVpZ2h0PzogbnVtYmVyIHwgc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBTcGVjaWZpZXMgdGhlIGVhc2luZyBmdW5jdGlvbiB0byB1c2UgZm9yIHRoZSBsb2FkaW5nIGFuaW1hdGlvbi4gQWNjZXB0cyBhbnkgdmFsaWQgQ1NTIGVhc2luZyBzdHJpbmcuXG4gICAqIERlZmF1bHQ6IFwiZWFzZVwiXG4gICAqL1xuICBlYXNpbmc/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGFuaW1hdGlvbiBzcGVlZCBvZiB0aGUgdG9wLWxvYWRpbmcgYmFyIGluIG1pbGxpc2Vjb25kcy5cbiAgICogRGVmYXVsdDogMjAwIG1pbGxpc2Vjb25kc1xuICAgKi9cbiAgc3BlZWQ/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIERlZmluZXMgdGhlIHotaW5kZXggcHJvcGVydHkgb2YgdGhlIHRvcC1sb2FkaW5nIGJhciwgY29udHJvbGxpbmcgaXRzIHN0YWNraW5nIG9yZGVyLlxuICAgKiBEZWZhdWx0OiAyMTQ3NDgzNjQ3XG4gICAqL1xuICB6SW5kZXg/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFNwZWNpZmllcyB0aGUgc2hhZG93IGVmZmVjdCB0byBiZSBhcHBsaWVkIHRvIHRoZSB0b3AtbG9hZGluZyBiYXIuXG4gICAqIEZvciBleGFtcGxlOiBcIjAgMCAxMHB4ICM1OWEyZmYsIDAgMCA1cHggIzU5YTJmZlwiXG4gICAqL1xuICBib3hTaGFkb3c/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFNwZWNpZmllcyB3aGV0aGVyIHRvIGFjY29tcGFueSB0aGUgbG9hZGluZyBiYXIgd2l0aCBhIHNwaW5uZXIuXG4gICAqIERlZmF1bHQ6IGZhbHNlXG4gICAqL1xuICBzaG93U3Bpbm5lcj86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFNwZWNpZmllcyBpZiBzZWFyY2ggcGFyYW1ldGVycyBzaG91bGQgYmUgaWdub3JlZCB3aGVuIGV2YWx1YXRpbmdcbiAgICogd2hldGhlciB0byBzdGFydCB0aGUgcHJvZ3Jlc3MgYmFyLlxuICAgKiBEZWZhdWx0OiBmYWxzZVxuICAgKi9cbiAgaWdub3JlU2VhcmNoUGFyYW1zPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogU3BlY2lmaWVzIHRoZSBkaXJlY3Rpb24gb2YgdGhlIGxvYWRpbmcgYmFyLlxuICAgKiBEZWZhdWx0OiBcImx0clwiXG4gICAqL1xuICBkaXI/OiAnbHRyJyB8ICdydGwnO1xufVxuXG4vKipcbiAqIERpc3BhdGNoZXMgdGhlIGV2ZW50IHRvIG1hbnVhbGx5IHN0YXJ0IHRoZSBIb2x5TG9hZGVyIHByb2dyZXNzIGJhci5cbiAqL1xuZXhwb3J0IGNvbnN0IHN0YXJ0SG9seUxvYWRlciA9ICgpOiB2b2lkID0+IHtcbiAgZG9jdW1lbnQuZGlzcGF0Y2hFdmVudChuZXcgRXZlbnQoU1RBUlRfSE9MWV9FVkVOVCkpO1xufTtcblxuLyoqXG4gKiBEaXNwYXRjaGVzIHRoZSBldmVudCB0byBtYW51YWxseSBzdG9wIHRoZSBIb2x5TG9hZGVyIHByb2dyZXNzIGJhci5cbiAqL1xuZXhwb3J0IGNvbnN0IHN0b3BIb2x5TG9hZGVyID0gKCk6IHZvaWQgPT4ge1xuICBkb2N1bWVudC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChTVE9QX0hPTFlfRVZFTlQpKTtcbn07XG5cbi8qKlxuICogSG9seUxvYWRlciBpcyBhIFJlYWN0IGNvbXBvbmVudCB0aGF0IHByb3ZpZGVzIGEgY3VzdG9taXphYmxlIHRvcC1sb2FkaW5nIHByb2dyZXNzIGJhci5cbiAqXG4gKiBAcGFyYW0ge0hvbHlMb2FkZXJQcm9wc30gcHJvcHMgVGhlIHByb3BlcnRpZXMgZm9yIGNvbmZpZ3VyaW5nIHRoZSBIb2x5TG9hZGVyLlxuICogQHJldHVybnMge251bGx9XG4gKi9cbmNvbnN0IEhvbHlMb2FkZXIgPSAoe1xuICBjb2xvciA9IERFRkFVTFRTLmNvbG9yLFxuICBpbml0aWFsUG9zaXRpb24gPSBERUZBVUxUUy5pbml0aWFsUG9zaXRpb24sXG4gIGhlaWdodCA9IERFRkFVTFRTLmhlaWdodCxcbiAgZWFzaW5nID0gREVGQVVMVFMuZWFzaW5nLFxuICBzcGVlZCA9IERFRkFVTFRTLnNwZWVkLFxuICB6SW5kZXggPSBERUZBVUxUUy56SW5kZXgsXG4gIGJveFNoYWRvdyA9IERFRkFVTFRTLmJveFNoYWRvdyxcbiAgc2hvd1NwaW5uZXIgPSBERUZBVUxUUy5zaG93U3Bpbm5lcixcbiAgaWdub3JlU2VhcmNoUGFyYW1zID0gREVGQVVMVFMuaWdub3JlU2VhcmNoUGFyYW1zLFxuICBkaXIgPSBERUZBVUxUUy5kaXIsIFxufTogSG9seUxvYWRlclByb3BzKTogbnVsbCA9PiB7XG4gIGNvbnN0IGhvbHlQcm9ncmVzc1JlZiA9IFJlYWN0LnVzZVJlZjxIb2x5UHJvZ3Jlc3MgfCBudWxsPihudWxsKTtcblxuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IHN0YXJ0UHJvZ3Jlc3MgPSAoKTogdm9pZCA9PiB7XG4gICAgICBpZiAoaG9seVByb2dyZXNzUmVmLmN1cnJlbnQgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICBob2x5UHJvZ3Jlc3NSZWYuY3VycmVudC5zdGFydCgpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHt9XG4gICAgfTtcblxuICAgIGNvbnN0IHN0b3BQcm9ncmVzcyA9ICgpOiB2b2lkID0+IHtcbiAgICAgIGlmIChob2x5UHJvZ3Jlc3NSZWYuY3VycmVudCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGhvbHlQcm9ncmVzc1JlZi5jdXJyZW50LmNvbXBsZXRlKCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge31cbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRmxhZyB0byBwcmV2ZW50IHJlZHVuZGFudCBwYXRjaGluZyBvZiBIaXN0b3J5IEFQSSBtZXRob2RzLlxuICAgICAqIFRoaXMgaXMgZXNzZW50aWFsIHRvIGF2b2lkIHB1c2hTdGF0ZSAmIHJlcGxhY2VTdGF0ZSBpbmNyZWFzaW5nbHkgbmVzdGluZ1xuICAgICAqIHdpdGhpbiBwYXRjaGVkIHZlcnNpb25zIG9mIGl0c2VsZlxuICAgICAqL1xuICAgIGxldCBpc0hpc3RvcnlQYXRjaGVkID0gZmFsc2U7XG5cbiAgICAvKipcbiAgICAgKiBFbmhhbmNlcyBicm93c2VyIGhpc3RvcnkgbWV0aG9kcyAocHVzaFN0YXRlIGFuZCByZXBsYWNlU3RhdGUpIHRvIGVuc3VyZSB0aGF0IHRoZVxuICAgICAqIHByb2dyZXNzIGluZGljYXRvciBpcyBhcHByb3ByaWF0ZWx5IGhhbHRlZCB3aGVuIG5hdmlnYXRpbmcgdGhyb3VnaCBzaW5nbGUtcGFnZSBhcHBsaWNhdGlvbnNcbiAgICAgKi9cbiAgICBjb25zdCBzdG9wUHJvZ3Jlc3NPbkhpc3RvcnlVcGRhdGUgPSAoKTogdm9pZCA9PiB7XG4gICAgICBpZiAoaXNIaXN0b3J5UGF0Y2hlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG9yaWdpbmFsUHVzaFN0YXRlID0gaGlzdG9yeS5wdXNoU3RhdGUuYmluZChoaXN0b3J5KTtcbiAgICAgIGhpc3RvcnkucHVzaFN0YXRlID0gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgY29uc3QgdXJsID0gYXJnc1syXTtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIHVybCAmJlxuICAgICAgICAgIGlzU2FtZVBhdGhuYW1lKHdpbmRvdy5sb2NhdGlvbi5ocmVmLCB1cmwpICYmXG4gICAgICAgICAgKGlnbm9yZVNlYXJjaFBhcmFtcyB8fFxuICAgICAgICAgICAgaGFzU2FtZVF1ZXJ5UGFyYW1ldGVycyh3aW5kb3cubG9jYXRpb24uaHJlZiwgdXJsKSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgb3JpZ2luYWxQdXNoU3RhdGUoLi4uYXJncyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN0b3BQcm9ncmVzcygpO1xuICAgICAgICBvcmlnaW5hbFB1c2hTdGF0ZSguLi5hcmdzKTtcbiAgICAgIH07XG5cbiAgICAgIC8vIFRoaXMgaXMgY3J1Y2lhbCBmb3IgTmV4dC5qcyBMaW5rIGNvbXBvbmVudHMgdXNpbmcgdGhlICdyZXBsYWNlJyBwcm9wLlxuICAgICAgY29uc3Qgb3JpZ2luYWxSZXBsYWNlU3RhdGUgPSBoaXN0b3J5LnJlcGxhY2VTdGF0ZS5iaW5kKGhpc3RvcnkpO1xuICAgICAgaGlzdG9yeS5yZXBsYWNlU3RhdGUgPSAoLi4uYXJncykgPT4ge1xuICAgICAgICBjb25zdCB1cmwgPSBhcmdzWzJdO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgdXJsICYmXG4gICAgICAgICAgaXNTYW1lUGF0aG5hbWUod2luZG93LmxvY2F0aW9uLmhyZWYsIHVybCkgJiZcbiAgICAgICAgICAoaWdub3JlU2VhcmNoUGFyYW1zIHx8XG4gICAgICAgICAgICBoYXNTYW1lUXVlcnlQYXJhbWV0ZXJzKHdpbmRvdy5sb2NhdGlvbi5ocmVmLCB1cmwpKVxuICAgICAgICApIHtcbiAgICAgICAgICBvcmlnaW5hbFJlcGxhY2VTdGF0ZSguLi5hcmdzKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgc3RvcFByb2dyZXNzKCk7XG4gICAgICAgIG9yaWdpbmFsUmVwbGFjZVN0YXRlKC4uLmFyZ3MpO1xuICAgICAgfTtcblxuICAgICAgaXNIaXN0b3J5UGF0Y2hlZCA9IHRydWU7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgY2xpY2sgZXZlbnRzIG9uIGFuY2hvciB0YWdzLCBzdGFydGluZyB0aGUgcHJvZ3Jlc3MgYmFyIGZvciBwYWdlIG5hdmlnYXRpb24uXG4gICAgICogSXQgY2hlY2tzIGZvciB2YXJpb3VzIGNvbmRpdGlvbnMgdG8gZGVjaWRlIHdoZXRoZXIgdG8gc3RhcnQgdGhlIHByb2dyZXNzIGJhciBvciBub3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge01vdXNlRXZlbnR9IGV2ZW50IFRoZSBtb3VzZSBldmVudCB0cmlnZ2VyZWQgYnkgY2xpY2tpbmcgYW4gYW5jaG9yIHRhZy5cbiAgICAgKi9cbiAgICBjb25zdCBoYW5kbGVDbGljayA9IChldmVudDogTW91c2VFdmVudCk6IHZvaWQgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQudGFyZ2V0IGFzIEhUTUxFbGVtZW50O1xuICAgICAgICBjb25zdCBhbmNob3IgPSB0YXJnZXQuY2xvc2VzdCgnYScpO1xuXG4gICAgICAgIGlmIChcbiAgICAgICAgICBhbmNob3IgPT09IG51bGwgfHxcbiAgICAgICAgICBhbmNob3IudGFyZ2V0ID09PSAnX2JsYW5rJyB8fFxuICAgICAgICAgIGFuY2hvci5oYXNBdHRyaWJ1dGUoJ2Rvd25sb2FkJykgfHxcbiAgICAgICAgICBldmVudC5jdHJsS2V5IHx8XG4gICAgICAgICAgZXZlbnQubWV0YUtleSB8fFxuICAgICAgICAgIC8vIFNraXAgaWYgVVJMIHBvaW50cyB0byBhIGRpZmZlcmVudCBkb21haW5cbiAgICAgICAgICAhaXNTYW1lSG9zdCh3aW5kb3cubG9jYXRpb24uaHJlZiwgYW5jaG9yLmhyZWYpIHx8XG4gICAgICAgICAgLy8gU2tpcCBpZiBVUkwgaXMgYSBzYW1lLXBhZ2UgYW5jaG9yIChocmVmPVwiI1wiLCBocmVmPVwiI3RvcFwiLCBldGMuKS5cbiAgICAgICAgICBpc1NhbWVQYWdlQW5jaG9yKHdpbmRvdy5sb2NhdGlvbi5ocmVmLCBhbmNob3IuaHJlZikgfHxcbiAgICAgICAgICAvLyBTa2lwIGlmIFVSTCB1c2VzIGEgbm9uLWh0dHAvaHR0cHMgcHJvdG9jb2wgKG1haWx0bzosIHRlbDosIGV0Yy4pLlxuICAgICAgICAgICF0b0Fic29sdXRlVVJMKGFuY2hvci5ocmVmKS5zdGFydHNXaXRoKCdodHRwJykgfHxcbiAgICAgICAgICAvLyBTa2lwIGlmIHRoZSBVUkwgaXMgdGhlIHNhbWUgYXMgdGhlIGN1cnJlbnQgcGFnZVxuICAgICAgICAgIChpc1NhbWVQYXRobmFtZSh3aW5kb3cubG9jYXRpb24uaHJlZiwgYW5jaG9yLmhyZWYpICYmXG4gICAgICAgICAgICAoaWdub3JlU2VhcmNoUGFyYW1zIHx8XG4gICAgICAgICAgICAgIGhhc1NhbWVRdWVyeVBhcmFtZXRlcnMod2luZG93LmxvY2F0aW9uLmhyZWYsIGFuY2hvci5ocmVmKSkpXG4gICAgICAgICkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXJ0UHJvZ3Jlc3MoKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHN0b3BQcm9ncmVzcygpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB0cnkge1xuICAgICAgaWYgKGhvbHlQcm9ncmVzc1JlZi5jdXJyZW50ID09PSBudWxsKSB7XG4gICAgICAgIGhvbHlQcm9ncmVzc1JlZi5jdXJyZW50ID0gbmV3IEhvbHlQcm9ncmVzcyh7XG4gICAgICAgICAgY29sb3IsXG4gICAgICAgICAgaGVpZ2h0LFxuICAgICAgICAgIGluaXRpYWxQb3NpdGlvbixcbiAgICAgICAgICBlYXNpbmcsXG4gICAgICAgICAgc3BlZWQsXG4gICAgICAgICAgekluZGV4LFxuICAgICAgICAgIGJveFNoYWRvdyxcbiAgICAgICAgICBzaG93U3Bpbm5lcixcbiAgICAgICAgICBkaXJcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgaGFuZGxlQ2xpY2spO1xuICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihTVEFSVF9IT0xZX0VWRU5ULCBzdGFydFByb2dyZXNzKTtcbiAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoU1RPUF9IT0xZX0VWRU5ULCBzdG9wUHJvZ3Jlc3MpO1xuICAgICAgc3RvcFByb2dyZXNzT25IaXN0b3J5VXBkYXRlKCk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHt9XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2xpY2snLCBoYW5kbGVDbGljayk7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFNUQVJUX0hPTFlfRVZFTlQsIHN0YXJ0UHJvZ3Jlc3MpO1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihTVE9QX0hPTFlfRVZFTlQsIHN0b3BQcm9ncmVzcyk7XG4gICAgfTtcbiAgfSwgW2hvbHlQcm9ncmVzc1JlZl0pO1xuXG4gIHJldHVybiBudWxsO1xufTtcblxuZXhwb3J0IGRlZmF1bHQgSG9seUxvYWRlcjtcbiIsImV4cG9ydCBjb25zdCBERUZBVUxUUyA9IHtcbiAgY29sb3I6ICcjNTlhMmZmJyxcbiAgaW5pdGlhbFBvc2l0aW9uOiAwLjA4LFxuICBoZWlnaHQ6IDQsXG4gIGVhc2luZzogJ2Vhc2UnLFxuICBzcGVlZDogMjAwLFxuICB6SW5kZXg6IDIxNDc0ODM2NDcsXG4gIHNob3dTcGlubmVyOiBmYWxzZSxcbiAgYm94U2hhZG93OiB1bmRlZmluZWQsXG4gIGlnbm9yZVNlYXJjaFBhcmFtczogZmFsc2UsXG4gIGRpcjogJ2x0cicsXG59IGFzIGNvbnN0O1xuXG5leHBvcnQgY29uc3QgU1RBUlRfSE9MWV9FVkVOVCA9ICdob2x5LXByb2dyZXNzLXN0YXJ0JztcbmV4cG9ydCBjb25zdCBTVE9QX0hPTFlfRVZFTlQgPSAnaG9seS1wcm9ncmVzcy1zdG9wJztcbiIsIi8qKlxuICogQ29udmVydHMgYSBnaXZlbiBVUkwgdG8gYW4gYWJzb2x1dGUgVVJMIGJhc2VkIG9uIHRoZSBjdXJyZW50IHdpbmRvdyBsb2NhdGlvbi5cbiAqIElmIHRoZSBpbnB1dCBVUkwgaXMgYWxyZWFkeSBhYnNvbHV0ZSwgaXQgcmVtYWlucyB1bmNoYW5nZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCAtIFRoZSBVUkwgdG8gYmUgY29udmVydGVkLiBDYW4gYmUgYW4gYWJzb2x1dGUgb3IgcmVsYXRpdmUgVVJMLlxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGFic29sdXRlIFVSTCBkZXJpdmVkIGZyb20gdGhlIGdpdmVuIFVSTCBhbmQgdGhlIGN1cnJlbnQgd2luZG93IGxvY2F0aW9uLlxuICovXG5leHBvcnQgY29uc3QgdG9BYnNvbHV0ZVVSTCA9ICh1cmw6IHN0cmluZyk6IHN0cmluZyA9PiB7XG4gIHJldHVybiBuZXcgVVJMKHVybCwgd2luZG93LmxvY2F0aW9uLmhyZWYpLmhyZWY7XG59O1xuXG4vKipcbiAqIERldGVybWluZXMgaWYgdHdvIFVSTHMgcmVmZXIgdG8gdGhlIHNhbWUgcGFnZSwgZGlmZmVyaW5nIG9ubHkgYnkgdGhlIGFuY2hvci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gY3VycmVudFVybCBUaGUgY3VycmVudCBVUkwuXG4gKiBAcGFyYW0ge3N0cmluZ30gbmV3VXJsIFRoZSBuZXcgVVJMIHRvIGNvbXBhcmUgd2l0aCB0aGUgY3VycmVudCBVUkwuXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgVVJMcyByZWZlciB0byB0aGUgc2FtZSBwYWdlIChleGNsdWRpbmcgdGhlIGFuY2hvciksIGZhbHNlIG90aGVyd2lzZS5cbiAqL1xuZXhwb3J0IGNvbnN0IGlzU2FtZVBhZ2VBbmNob3IgPSAoXG4gIGN1cnJlbnRVcmw6IHN0cmluZyxcbiAgbmV3VXJsOiBzdHJpbmcsXG4pOiBib29sZWFuID0+IHtcbiAgY29uc3QgY3VycmVudCA9IG5ldyBVUkwodG9BYnNvbHV0ZVVSTChjdXJyZW50VXJsKSk7XG4gIGNvbnN0IG5leHQgPSBuZXcgVVJMKHRvQWJzb2x1dGVVUkwobmV3VXJsKSk7XG4gIHJldHVybiBjdXJyZW50LmhyZWYuc3BsaXQoJyMnKVswXSA9PT0gbmV4dC5ocmVmLnNwbGl0KCcjJylbMF07XG59O1xuXG4vKipcbiAqIERldGVybWluZXMgaWYgdHdvIFVSTHMgaGF2ZSB0aGUgc2FtZSBob3N0LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBjdXJyZW50VXJsIFRoZSBjdXJyZW50IFVSTC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBuZXdVcmwgVGhlIG5ldyBVUkwgdG8gY29tcGFyZSB3aXRoIHRoZSBjdXJyZW50IFVSTC5cbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBVUkxzIGhhdmUgdGhlIHNhbWUgaG9zdCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5leHBvcnQgY29uc3QgaXNTYW1lSG9zdCA9IChjdXJyZW50VXJsOiBzdHJpbmcsIG5ld1VybDogc3RyaW5nKTogYm9vbGVhbiA9PiB7XG4gIGNvbnN0IGN1cnJlbnQgPSBuZXcgVVJMKHRvQWJzb2x1dGVVUkwoY3VycmVudFVybCkpO1xuICBjb25zdCBuZXh0ID0gbmV3IFVSTCh0b0Fic29sdXRlVVJMKG5ld1VybCkpO1xuICByZXR1cm4gKFxuICAgIGN1cnJlbnQuaG9zdG5hbWUucmVwbGFjZSgvXnd3d1xcLi8sICcnKSA9PT1cbiAgICBuZXh0Lmhvc3RuYW1lLnJlcGxhY2UoL153d3dcXC4vLCAnJylcbiAgKTtcbn07XG5cbmNvbnN0IHBhcmFtc0FyZUVxdWFsID0gKHBhcmFtczE6IFVSTFNlYXJjaFBhcmFtcywgcGFyYW1zMjogVVJMU2VhcmNoUGFyYW1zKSA9PlxuICBBcnJheS5mcm9tKHBhcmFtczEpLmV2ZXJ5KFxuICAgIChba2V5LCB2YWx1ZV0pID0+IHBhcmFtczIuaGFzKGtleSkgJiYgcGFyYW1zMi5nZXQoa2V5KSA9PT0gdmFsdWUsXG4gICk7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiB0d28gVVJMcyBoYXZlIHRoZSBzYW1lIHF1ZXJ5IHBhcmFtZXRlcnMuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGN1cnJlbnRVcmwgVGhlIGN1cnJlbnQgVVJMLlxuICogQHBhcmFtIHtzdHJpbmd9IG5ld1VybCBUaGUgbmV3IFVSTCB0byBjb21wYXJlIHdpdGggdGhlIGN1cnJlbnQgVVJMLlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIFVSTHMgaGF2ZSB0aGUgc2FtZSBxdWVyeSBwYXJhbWV0ZXJzLCBmYWxzZSBvdGhlcndpc2UuXG4gKi9cbmV4cG9ydCBjb25zdCBoYXNTYW1lUXVlcnlQYXJhbWV0ZXJzID0gKFxuICBjdXJyZW50VXJsOiBzdHJpbmcsXG4gIG5ld1VybDogc3RyaW5nIHwgVVJMLFxuKTogYm9vbGVhbiA9PiB7XG4gIGNvbnN0IGN1cnJlbnQgPSBuZXcgVVJMKHRvQWJzb2x1dGVVUkwoY3VycmVudFVybCkpO1xuICBjb25zdCBuZXh0ID0gbmV3VXJsIGluc3RhbmNlb2YgVVJMID8gbmV3VXJsIDogbmV3IFVSTCh0b0Fic29sdXRlVVJMKG5ld1VybCkpO1xuXG4gIGNvbnN0IGN1cnJlbnRQYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKGN1cnJlbnQuc2VhcmNoKTtcbiAgY29uc3QgbmV4dFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMobmV4dC5zZWFyY2gpO1xuXG4gIHJldHVybiAoXG4gICAgcGFyYW1zQXJlRXF1YWwoY3VycmVudFBhcmFtcywgbmV4dFBhcmFtcykgJiZcbiAgICBwYXJhbXNBcmVFcXVhbChuZXh0UGFyYW1zLCBjdXJyZW50UGFyYW1zKVxuICApO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHR3byBVUkxzIGhhdmUgdGhlIHNhbWUgcGF0aG5hbWUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGN1cnJlbnRVcmwgVGhlIGN1cnJlbnQgVVJMLlxuICogQHBhcmFtIHtzdHJpbmd9IG5ld1VybCBUaGUgbmV3IFVSTCB0byBjb21wYXJlIHdpdGggdGhlIGN1cnJlbnQgVVJMLlxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIFVSTHMgaGF2ZSB0aGUgc2FtZSBwYXRobmFtZSwgZmFsc2Ugb3RoZXJ3aXNlLlxuICovXG5leHBvcnQgY29uc3QgaXNTYW1lUGF0aG5hbWUgPSAoXG4gIGN1cnJlbnRVcmw6IHN0cmluZyxcbiAgbmV3VXJsOiBzdHJpbmcgfCBVUkwsXG4pOiBib29sZWFuID0+IHtcbiAgY29uc3QgY3VycmVudCA9IG5ldyBVUkwodG9BYnNvbHV0ZVVSTChjdXJyZW50VXJsKSk7XG4gIGNvbnN0IG5leHQgPSBuZXdVcmwgaW5zdGFuY2VvZiBVUkwgPyBuZXdVcmwgOiBuZXcgVVJMKHRvQWJzb2x1dGVVUkwobmV3VXJsKSk7XG4gIHJldHVybiBjdXJyZW50LnBhdGhuYW1lID09PSBuZXh0LnBhdGhuYW1lO1xufTtcblxuZXhwb3J0IGNvbnN0IGNsYW1wID0gKG46IG51bWJlciwgbWluOiBudW1iZXIsIG1heDogbnVtYmVyKTogbnVtYmVyID0+XG4gIE1hdGgubWF4KG1pbiwgTWF0aC5taW4obiwgbWF4KSk7XG5cbmV4cG9ydCBjb25zdCBxdWV1ZSA9ICgoKSA9PiB7XG4gIGNvbnN0IHBlbmRpbmc6IEFycmF5PChuZXh0OiAoKSA9PiB2b2lkKSA9PiB2b2lkPiA9IFtdO1xuXG4gIGNvbnN0IG5leHQgPSAoKTogdm9pZCA9PiB7XG4gICAgY29uc3QgZm4gPSBwZW5kaW5nLnNoaWZ0KCk7XG4gICAgaWYgKGZuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGZuKG5leHQpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gKGZuOiAobmV4dDogKCkgPT4gdm9pZCkgPT4gdm9pZCkgPT4ge1xuICAgIHBlbmRpbmcucHVzaChmbik7XG4gICAgaWYgKHBlbmRpbmcubGVuZ3RoID09PSAxKSB7XG4gICAgICBuZXh0KCk7XG4gICAgfVxuICB9O1xufSkoKTtcblxuZXhwb3J0IGNvbnN0IHJlcGFpbnRFbGVtZW50ID0gKG9iajogSFRNTEVsZW1lbnQpOiBIVE1MRWxlbWVudCA9PiB7XG4gIHZvaWQgb2JqLm9mZnNldFdpZHRoO1xuICByZXR1cm4gb2JqO1xufTtcbiIsImltcG9ydCB7IERFRkFVTFRTIH0gZnJvbSAnLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgY2xhbXAsIHF1ZXVlLCByZXBhaW50RWxlbWVudCB9IGZyb20gJy4vdXRpbHMnO1xuXG50eXBlIEhvbHlQcm9ncmVzc1Byb3BzID0ge1xuICAvKipcbiAgICogU3BlY2lmaWVzIHRoZSBtaW5pbXVtIHZhbHVlIGZvciB0aGUgcHJvZ3Jlc3MgYmFyIHRvIHN0YXJ0IGF0LlxuICAgKiBEZWZhdWx0OiAwLjA4ICg4JSBvZiB0aGUgdG90YWwgd2lkdGgpXG4gICAqL1xuICBpbml0aWFsUG9zaXRpb246IG51bWJlcjtcblxuICAvKipcbiAgICogU3BlY2lmaWVzIHRoZSBDU1MgZWFzaW5nIHR5cGUgZm9yIHRoZSBwcm9ncmVzcyBiYXIgYW5pbWF0aW9uLlxuICAgKiBEZWZhdWx0OiAnbGluZWFyJ1xuICAgKi9cbiAgZWFzaW5nOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFNwZWNpZmllcyB0aGUgc3BlZWQgb2YgdGhlIHByb2dyZXNzIGJhciBhbmltYXRpb24gaW4gbWlsbGlzZWNvbmRzLlxuICAgKiBEZWZhdWx0OiAyMDBcbiAgICovXG4gIHNwZWVkOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFNwZWNpZmllcyB0aGUgY29sb3Igb2YgdGhlIHByb2dyZXNzIGJhci5cbiAgICogRGVmYXVsdDogJyM1OWEyZmYnXG4gICAqL1xuICBjb2xvcjogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBTcGVjaWZpZXMgdGhlIGhlaWdodCBvZiB0aGUgcHJvZ3Jlc3MgYmFyIGluIGVpdGhlciBwaXhlbHMgKG51bWJlcikgb3IgY3NzIHVuaXQgKHN0cmluZykuXG4gICAqIERlZmF1bHQ6IDRcbiAgICovXG4gIGhlaWdodDogbnVtYmVyIHwgc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBTcGVjaWZpZXMgdGhlIHotaW5kZXggb2YgdGhlIHByb2dyZXNzIGJhci5cbiAgICogRGVmYXVsdDogMjE0NzQ4MzY0N1xuICAgKi9cbiAgekluZGV4OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFNwZWNpZmllcyB0aGUgc2hhZG93IGVmZmVjdCB0byBiZSBhcHBsaWVkIHRvIHRoZSBwcm9ncmVzcyBiYXIuXG4gICAqIEZvciBleGFtcGxlOiBcIjAgMCAxMHB4ICM1OWEyZmYsIDAgMCA1cHggIzU5YTJmZlwiXG4gICAqL1xuICBib3hTaGFkb3c/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFNwZWNpZmllcyB3aGV0aGVyIHRvIGFjY29tcGFueSB0aGUgbG9hZGluZyBiYXIgd2l0aCBhIHNwaW5uZXIuXG4gICAqIERlZmF1bHQ6IGZhbHNlXG4gICAqL1xuICBzaG93U3Bpbm5lcj86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFNwZWNpZmllcyB0aGUgZGlyZWN0aW9uIG9mIHRoZSBsb2FkaW5nIGJhci5cbiAgICogRGVmYXVsdDogXCJsdHJcIlxuICAgKi9cbiAgZGlyPzogJ2x0cicgfCAncnRsJztcbn07XG5cbnR5cGUgVHJhbnNmb3JtU3RyYXRlZ3kgPSAndHJhbnNsYXRlM2QnIHwgJ3RyYW5zbGF0ZScgfCAnbWFyZ2luJztcblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSBIb2x5UHJvZ3Jlc3MgYmFyLlxuICogQGNsYXNzXG4gKiBAY2xhc3NkZXNjIEEgZmxleGlibGUsIGN1c3RvbWl6YWJsZSBwcm9ncmVzcyBiYXIgZm9yIHdlYiBhcHBsaWNhdGlvbnMuXG4gKi9cbmV4cG9ydCBjbGFzcyBIb2x5UHJvZ3Jlc3Mge1xuICBwcml2YXRlIHJlYWRvbmx5IHNldHRpbmdzOiBIb2x5UHJvZ3Jlc3NQcm9wcztcblxuICAvKipcbiAgICogVGhlIHByb2dyZXMgb2YgdGhlIGJhciBhcyBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDEuXG4gICAqIElmIDAgaXMgcmVhY2hlZCwgdGhlIHN0YXR1cyBpcyBudWxsXG4gICAqL1xuICBwcml2YXRlIHByb2dyZXNzTjogbnVtYmVyIHwgbnVsbDtcblxuICBwcml2YXRlIGJhcjogSFRNTEVsZW1lbnQgfCBudWxsO1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBIb2x5UHJvZ3Jlc3MgaW5zdGFuY2UuXG4gICAqIEBwYXJhbSB7UGFydGlhbDxIb2x5UHJvZ3Jlc3NQcm9wcz59IFtjdXN0b21TZXR0aW5nc10gLSBPcHRpb25hbCBjdXN0b20gc2V0dGluZ3MgdG8gb3ZlcnJpZGUgZGVmYXVsdHMuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihjdXN0b21TZXR0aW5ncz86IFBhcnRpYWw8SG9seVByb2dyZXNzUHJvcHM+KSB7XG4gICAgdGhpcy5zZXR0aW5ncyA9IHsgLi4uREVGQVVMVFMsIC4uLmN1c3RvbVNldHRpbmdzIH07XG4gICAgdGhpcy5wcm9ncmVzc04gPSBudWxsO1xuICAgIHRoaXMuYmFyID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBwcm9ncmVzcyB0byBhIHNwZWNpZmljIHZhbHVlLlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge251bWJlcn0gbiAtIFRoZSBuZXcgcHJvZ3Jlc3MgdmFsdWUgKDAgdG8gMSkuXG4gICAqIEByZXR1cm5zIHtIb2x5UHJvZ3Jlc3N9IFRoZSBjdXJyZW50IGluc3RhbmNlIGZvciBjaGFpbmluZyBtZXRob2RzLlxuICAgKi9cbiAgcHJpdmF0ZSByZWFkb25seSBzZXRUbyA9IChuOiBudW1iZXIpOiBIb2x5UHJvZ3Jlc3MgPT4ge1xuICAgIGNvbnN0IGlzU3RhcnRlZCA9IHR5cGVvZiB0aGlzLnByb2dyZXNzTiA9PT0gJ251bWJlcic7XG5cbiAgICBuID0gY2xhbXAobiwgdGhpcy5zZXR0aW5ncy5pbml0aWFsUG9zaXRpb24sIDEpO1xuXG4gICAgdGhpcy5wcm9ncmVzc04gPSBuID09PSAxID8gbnVsbCA6IG47XG5cbiAgICBjb25zdCBwcm9ncmVzc0JhciA9IHRoaXMuZ2V0T3JDcmVhdGVCYXIoIWlzU3RhcnRlZCk7XG5cbiAgICBpZiAoIXByb2dyZXNzQmFyKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICByZXBhaW50RWxlbWVudChwcm9ncmVzc0Jhcik7XG5cbiAgICBxdWV1ZSgobmV4dCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLmJhcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIE9iamVjdC5hc3NpZ24odGhpcy5iYXIuc3R5bGUsIHRoaXMuYmFyUG9zaXRpb25DU1MobiksIHtcbiAgICAgICAgdHJhbnNpdGlvbjogYGFsbCAke3RoaXMuc2V0dGluZ3Muc3BlZWR9bXMgJHt0aGlzLnNldHRpbmdzLmVhc2luZ31gLFxuICAgICAgfSk7XG5cbiAgICAgIGlmIChuID09PSAxKSB7XG4gICAgICAgIHByb2dyZXNzQmFyLnN0eWxlLnRyYW5zaXRpb24gPSAnbm9uZSc7XG4gICAgICAgIHByb2dyZXNzQmFyLnN0eWxlLm9wYWNpdHkgPSAnMSc7XG4gICAgICAgIHJlcGFpbnRFbGVtZW50KHByb2dyZXNzQmFyKTtcblxuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICBwcm9ncmVzc0Jhci5zdHlsZS50cmFuc2l0aW9uID0gYGFsbCAke3RoaXMuc2V0dGluZ3Muc3BlZWR9bXMgbGluZWFyYDtcbiAgICAgICAgICBwcm9ncmVzc0Jhci5zdHlsZS5vcGFjaXR5ID0gJzAnO1xuICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVCYXJGcm9tRE9NKCk7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgfSwgdGhpcy5zZXR0aW5ncy5zcGVlZCk7XG5cbiAgICAgICAgICB0aGlzLnJlbW92ZVNwaW5uZXJGcm9tRE9NKCk7XG4gICAgICAgIH0sIHRoaXMuc2V0dGluZ3Muc3BlZWQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2V0VGltZW91dChuZXh0LCB0aGlzLnNldHRpbmdzLnNwZWVkKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogQ29udmVydHMgYSBwcm9ncmVzcyB2YWx1ZSAoMCB0byAxKSBpbnRvIGEgcGVyY2VudGFnZSByZXByZXNlbnRhdGlvbi5cbiAgICogVXNlZCBmb3IgY2FsY3VsYXRpbmcgdGhlIHZpc3VhbCB3aWR0aCBvZiB0aGUgcHJvZ3Jlc3MgYmFyLlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge251bWJlcn0gbiAtIFRoZSBwcm9ncmVzcyB2YWx1ZSB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgcGVyY2VudGFnZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgcHJvZ3Jlc3MgdmFsdWUuXG4gICAqL1xuICBwcml2YXRlIHJlYWRvbmx5IHRvQmFyUGVyY2VudGFnZSA9IChuOiBudW1iZXIpOiBudW1iZXIgPT5cbiAgICB0aGlzLnNldHRpbmdzLmRpciA9PT0gJ2x0cicgPyAoLTEgKyBuKSAqIDEwMCA6ICgxIC0gbikgKiAxMDA7XG5cbiAgLyoqXG4gICAqIEluaXRpYXRlcyB0aGUgcHJvZ3Jlc3MgYmFyJ3MgbW92ZW1lbnQuIElmIGFscmVhZHkgc3RhcnRlZCwgaXQgY29udGludWVzIGZyb20gdGhlIGN1cnJlbnQgcG9zaXRpb24uXG4gICAqIEF1dG9tYXRpY2FsbHkgaGFuZGxlcyBhdXRvbWF0aWMgaW5jcmVtZW50YXRpb24gKCd0cmlja2xlJykgaWYgZW5hYmxlZC5cbiAgICogQHB1YmxpY1xuICAgKiBAcmV0dXJucyB7SG9seVByb2dyZXNzfSBUaGUgY3VycmVudCBpbnN0YW5jZSBmb3IgY2hhaW5pbmcgbWV0aG9kcy5cbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBzdGFydCA9ICgpOiBIb2x5UHJvZ3Jlc3MgPT4ge1xuICAgIGlmICh0aGlzLnByb2dyZXNzTiA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5zZXRUbygwKTtcblxuICAgICAgdGhpcy5zdGFydFRyaWNrbGUoKTtcblxuICAgICAgaWYgKHRoaXMuc2V0dGluZ3Muc2hvd1NwaW5uZXIgPT09IHRydWUpIHtcbiAgICAgICAgdGhpcy5jcmVhdGVTcGlubmVyKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFBlcmZvcm1zIGF1dG9tYXRpYyBpbmNyZW1lbnRhdGlvbiBvZiB0aGUgcHJvZ3Jlc3MgYmFyLlxuICAgKiBUaGlzIGZ1bmN0aW9uIGlzIHJlY3Vyc2l2ZSBhbmQgY29udGludWVzIHRvIGluY3JlbWVudCB0aGUgcHJvZ3Jlc3MgYXQgaW50ZXJ2YWxzIGRlZmluZWQgYnkgYHNwZWVkYC5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIHByaXZhdGUgcmVhZG9ubHkgc3RhcnRUcmlja2xlID0gKCk6IHZvaWQgPT4ge1xuICAgIGNvbnN0IHJ1biA9ICgpOiB2b2lkID0+IHtcbiAgICAgIGlmICh0aGlzLnByb2dyZXNzTiA9PT0gbnVsbCkgcmV0dXJuO1xuXG4gICAgICB0aGlzLmluY3JlbWVudFN0YXR1cygpO1xuICAgICAgc2V0VGltZW91dChydW4sIHRoaXMuc2V0dGluZ3Muc3BlZWQpO1xuICAgIH07XG5cbiAgICBzZXRUaW1lb3V0KHJ1biwgdGhpcy5zZXR0aW5ncy5zcGVlZCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENvbXBsZXRlcyB0aGUgcHJvZ3Jlc3MsIG1vdmluZyBpdCB0byAxMDAlXG4gICAqIEBwdWJsaWNcbiAgICogQHJldHVybnMge0hvbHlQcm9ncmVzc30gVGhlIGN1cnJlbnQgaW5zdGFuY2UgZm9yIGNoYWluaW5nIG1ldGhvZHMuXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgY29tcGxldGUgPSAoKTogSG9seVByb2dyZXNzID0+IHRoaXMuc2V0VG8oMSk7XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgYW4gaW5jcmVtZW50IHZhbHVlIGJhc2VkIG9uIHRoZSBjdXJyZW50IHN0YXR1cyBvZiB0aGUgcHJvZ3Jlc3MuXG4gICAqIFRoaXMgaXMgdXNlZCB0byBkZXRlcm1pbmUgdGhlIGFtb3VudCBvZiBwcm9ncmVzcyB0byBhZGQgZHVyaW5nIGF1dG9tYXRpYyBpbmNyZW1lbnRhdGlvbi5cbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXR1cyAtIFRoZSBjdXJyZW50IHByb2dyZXNzIHN0YXR1cy5cbiAgICogQHJldHVybnMge251bWJlcn0gVGhlIGNhbGN1bGF0ZWQgaW5jcmVtZW50IHZhbHVlLlxuICAgKi9cbiAgcHJpdmF0ZSByZWFkb25seSBjYWxjdWxhdGVJbmNyZW1lbnQgPSAoc3RhdHVzOiBudW1iZXIpOiBudW1iZXIgPT4ge1xuICAgIGNvbnN0IGJhc2UgPSAwLjE7XG4gICAgY29uc3Qgc2NhbGUgPSA1O1xuICAgIHJldHVybiBiYXNlICogTWF0aC5leHAoLXNjYWxlICogc3RhdHVzKTtcbiAgfTtcblxuICAvKipcbiAgICogSW5jcmVtZW50cyB0aGUgcHJvZ3Jlc3MgYmFyIGJ5IGEgc3BlY2lmaWVkIGFtb3VudCwgb3IgYnkgYW4gYW1vdW50IGRldGVybWluZWQgYnkgYGNhbGN1bGF0ZUluY3JlbWVudGAgaWYgbm90IHNwZWNpZmllZC5cbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IFthbW91bnRdIC0gVGhlIGFtb3VudCB0byBpbmNyZW1lbnQgdGhlIHByb2dyZXNzIGJhci5cbiAgICogQHJldHVybnMge0hvbHlQcm9ncmVzc30gVGhlIGN1cnJlbnQgaW5zdGFuY2UgZm9yIGNoYWluaW5nIG1ldGhvZHMuXG4gICAqL1xuICBwcml2YXRlIHJlYWRvbmx5IGluY3JlbWVudFN0YXR1cyA9IChhbW91bnQ/OiBudW1iZXIpOiBIb2x5UHJvZ3Jlc3MgPT4ge1xuICAgIGlmICh0aGlzLnByb2dyZXNzTiA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RhcnQoKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5wcm9ncmVzc04gPiAxKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGFtb3VudCAhPT0gJ251bWJlcicpIHtcbiAgICAgIGFtb3VudCA9IHRoaXMuY2FsY3VsYXRlSW5jcmVtZW50KHRoaXMucHJvZ3Jlc3NOKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEbyBub3QgY2xhbXAgdG8gMSAtIHRoZSBwcm9ncmVzcyBiYXIgY2FuIG9ubHkgZnVsbHkgZmluaXNoIGJ5IGJlaW5nIHNldCB0byAxIGJ5IHRoZSB1c2VyLlxuICAgICAqIFRoaXMgcHJldmVudHMgdGhlIHByb2dyZXNzIGJhciBjb21wbGV0aW5nIGl0c2VsZiBieSBpbmNyZW1lbnRpbmcgdG8gMSBiZWZvcmUgYW4gYWN0aW9uIGhhcyBiZWVuIGNvbXBsZXRlZCBvciBhIHBhZ2UgbG9hZGVkLlxuICAgICAqL1xuICAgIHRoaXMucHJvZ3Jlc3NOID0gY2xhbXAodGhpcy5wcm9ncmVzc04gKyBhbW91bnQsIDAsIDAuOTk0KTtcblxuICAgIHJldHVybiB0aGlzLnNldFRvKHRoaXMucHJvZ3Jlc3NOKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhbmQgaW5pdGlhbGl6ZXMgYSBuZXcgcHJvZ3Jlc3MgYmFyIGVsZW1lbnQgaW4gdGhlIERPTS5cbiAgICogSXQgc2V0cyB1cCB0aGUgbmVjZXNzYXJ5IHN0eWxlcyBhbmQgYXBwZW5kcyB0aGUgZWxlbWVudCB0byB0aGUgZG9jdW1lbnQgYm9keS5cbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtib29sZWFufSBmcm9tU3RhcnQgLSBJbmRpY2F0ZXMgaWYgdGhlIGJhciBpcyBjcmVhdGVkIGZyb20gdGhlIHN0YXJ0IHBvc2l0aW9uLlxuICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnQgfCBudWxsfSBUaGUgY3JlYXRlZCBwcm9ncmVzcyBiYXIgZWxlbWVudCwgb3IgbnVsbCBpZiBjcmVhdGlvbiBmYWlscy5cbiAgICovXG4gIHByaXZhdGUgcmVhZG9ubHkgY3JlYXRlQmFyID0gKGZyb21TdGFydDogYm9vbGVhbik6IEhUTUxFbGVtZW50IHwgbnVsbCA9PiB7XG4gICAgY29uc3QgYmFyQ29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgYmFyQ29udGFpbmVyLmlkID0gJ2hvbHktcHJvZ3Jlc3MnO1xuICAgIGJhckNvbnRhaW5lci5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xuICAgIGJhckNvbnRhaW5lci5pbm5lckhUTUwgPSAnPGRpdiBjbGFzcz1cImJhclwiIHJvbGU9XCJiYXJcIj48L2Rpdj4nO1xuXG4gICAgdGhpcy5iYXIgPSBiYXJDb250YWluZXIucXVlcnlTZWxlY3RvcihcbiAgICAgICdbcm9sZT1cImJhclwiXScsXG4gICAgKSBzYXRpc2ZpZXMgSFRNTEVsZW1lbnQgfCBudWxsO1xuXG4gICAgaWYgKCF0aGlzLmJhcikge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgcGVyY2VudGFnZSA9IHRoaXMudG9CYXJQZXJjZW50YWdlKFxuICAgICAgZnJvbVN0YXJ0ID8gMCA6ICh0aGlzLnByb2dyZXNzTiA/PyAwKSxcbiAgICApO1xuXG4gICAgdGhpcy5iYXIuc3R5bGUuYmFja2dyb3VuZCA9IHRoaXMuc2V0dGluZ3MuY29sb3I7XG4gICAgaWYgKHR5cGVvZiB0aGlzLnNldHRpbmdzLmhlaWdodCA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRoaXMuYmFyLnN0eWxlLmhlaWdodCA9IGAke3RoaXMuc2V0dGluZ3MuaGVpZ2h0fXB4YDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5iYXIuc3R5bGUuaGVpZ2h0ID0gdGhpcy5zZXR0aW5ncy5oZWlnaHQ7XG4gICAgfVxuICAgIHRoaXMuYmFyLnN0eWxlLnpJbmRleCA9IHRoaXMuc2V0dGluZ3MuekluZGV4LnRvU3RyaW5nKCk7XG4gICAgdGhpcy5iYXIuc3R5bGUucG9zaXRpb24gPSAnZml4ZWQnO1xuICAgIHRoaXMuYmFyLnN0eWxlLndpZHRoID0gJzEwMCUnO1xuICAgIHRoaXMuYmFyLnN0eWxlLnRvcCA9ICcwJztcbiAgICB0aGlzLmJhci5zdHlsZS5sZWZ0ID0gJzAnO1xuICAgIHRoaXMuYmFyLnN0eWxlLnRyYW5zaXRpb24gPSAnYWxsIDAgbGluZWFyJztcbiAgICB0aGlzLmJhci5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlM2QoJHtwZXJjZW50YWdlfSUsMCwwKWA7XG4gICAgdGhpcy5iYXIuc3R5bGUuYm94U2hhZG93ID0gdGhpcy5zZXR0aW5ncy5ib3hTaGFkb3cgPz8gJyc7XG5cbiAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGJhckNvbnRhaW5lcik7XG5cbiAgICByZXR1cm4gYmFyQ29udGFpbmVyO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuZCBpbml0aWFsaXplcyBhIG5ldyBzcGlubmVyIGVsZW1lbnQgaW4gdGhlIERPTS5cbiAgICogSXQgc2V0cyB1cCB0aGUgbmVjZXNzYXJ5IHN0eWxlcyBhbmQgYXBwZW5kcyB0aGUgZWxlbWVudCB0byB0aGUgZG9jdW1lbnQgYm9keS5cbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBwcml2YXRlIHJlYWRvbmx5IGNyZWF0ZVNwaW5uZXIgPSAoKTogdm9pZCA9PiB7XG4gICAgLyoqIG9ubHkgY3JlYXRlU3Bpbm5lciBpZiBpdCBkb2Vzbid0IGV4aXN0ICovXG4gICAgaWYgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdob2x5LXByb2dyZXNzLXNwaW5uZXInKSAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHNwaW5uZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBzcGlubmVyLmlkID0gJ2hvbHktcHJvZ3Jlc3Mtc3Bpbm5lcic7XG4gICAgc3Bpbm5lci5zdHlsZS5wb2ludGVyRXZlbnRzID0gJ25vbmUnO1xuXG4gICAgc3Bpbm5lci5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICBzcGlubmVyLnN0eWxlLnBvc2l0aW9uID0gJ2ZpeGVkJztcbiAgICBzcGlubmVyLnN0eWxlLnpJbmRleCA9IHRoaXMuc2V0dGluZ3MuekluZGV4LnRvU3RyaW5nKCk7XG4gICAgc3Bpbm5lci5zdHlsZS50b3AgPSAnMTVweCc7XG4gICAgc3Bpbm5lci5zdHlsZS5yaWdodCA9ICcxNXB4JztcblxuICAgIHNwaW5uZXIuc3R5bGUud2lkdGggPSAnMThweCc7XG4gICAgc3Bpbm5lci5zdHlsZS5oZWlnaHQgPSAnMThweCc7XG4gICAgc3Bpbm5lci5zdHlsZS5ib3hTaXppbmcgPSAnYm9yZGVyLWJveCc7XG5cbiAgICBzcGlubmVyLnN0eWxlLmJvcmRlciA9ICdzb2xpZCAycHggdHJhbnNwYXJlbnQnO1xuICAgIHNwaW5uZXIuc3R5bGUuYm9yZGVyVG9wQ29sb3IgPSB0aGlzLnNldHRpbmdzLmNvbG9yO1xuICAgIHNwaW5uZXIuc3R5bGUuYm9yZGVyTGVmdENvbG9yID0gdGhpcy5zZXR0aW5ncy5jb2xvcjtcbiAgICBzcGlubmVyLnN0eWxlLmJvcmRlclJhZGl1cyA9ICc1MCUnO1xuICAgIHNwaW5uZXIuc3R5bGUuYW5pbWF0aW9uID0gJ2hvbHktcHJvZ3Jlc3Mtc3Bpbm5lciA0MDBtcyBsaW5lYXIgaW5maW5pdGUnO1xuXG4gICAgY29uc3Qga2V5ZnJhbWVzID0gYFxuICAgICAgQGtleWZyYW1lcyBob2x5LXByb2dyZXNzLXNwaW5uZXIge1xuICAgICAgICAwJSAgIHsgdHJhbnNmb3JtOiByb3RhdGUoMGRlZyk7IH1cbiAgICAgICAgMTAwJSB7IHRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7IH1cbiAgICAgIH1cbiAgICBgO1xuXG4gICAgY29uc3Qgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgIHN0eWxlLmlubmVySFRNTCA9IGtleWZyYW1lcztcbiAgICBzcGlubmVyLmFwcGVuZENoaWxkKHN0eWxlKTtcblxuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc3Bpbm5lcik7XG4gIH07XG5cbiAgcHJpdmF0ZSByZWFkb25seSBnZXRPckNyZWF0ZUJhciA9IChmcm9tU3RhcnQ6IGJvb2xlYW4pOiBIVE1MRWxlbWVudCB8IG51bGwgPT5cbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaG9seS1wcm9ncmVzcycpID8/IHRoaXMuY3JlYXRlQmFyKGZyb21TdGFydCk7XG5cbiAgcHJpdmF0ZSByZWFkb25seSByZW1vdmVCYXJGcm9tRE9NID0gKCk6IHZvaWQgPT5cbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaG9seS1wcm9ncmVzcycpPy5yZW1vdmUoKTtcblxuICBwcml2YXRlIHJlYWRvbmx5IHJlbW92ZVNwaW5uZXJGcm9tRE9NID0gKCk6IHZvaWQgPT5cbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnaG9seS1wcm9ncmVzcy1zcGlubmVyJyk/LnJlbW92ZSgpO1xuXG4gIC8qKlxuICAgKiBEZXRlcm1pbmVzIHRoZSBtb3N0IHN1aXRhYmxlIENTUyBwb3NpdGlvbmluZyBzdHJhdGVneSBiYXNlZCBvbiBicm93c2VyIGNhcGFiaWxpdGllcy5cbiAgICogQ2hlY2tzIGZvciB0cmFuc2Zvcm0gcHJvcGVydGllcyB3aXRoIHZlbmRvciBwcmVmaXhlcyBhbmQgc3RhbmRhcmQgdW4tcHJlZml4ZWQgcHJvcGVydGllcy5cbiAgICogQHByaXZhdGVcbiAgICogQHJldHVybnMge1RyYW5zZm9ybVN0cmF0ZWd5fSAtIFRoZSBvcHRpbWFsIENTUyBwb3NpdGlvbmluZyBzdHJhdGVneSAoJ3RyYW5zbGF0ZTNkJywgJ3RyYW5zbGF0ZScsIG9yICdtYXJnaW4nKS5cbiAgICovXG4gIHByaXZhdGUgcmVhZG9ubHkgZ2V0VHJhbnNmb3JtU3RyYXRlZ3kgPSAoKTogVHJhbnNmb3JtU3RyYXRlZ3kgPT4ge1xuICAgIGNvbnN0IHN0eWxlID0gZG9jdW1lbnQuYm9keS5zdHlsZTtcbiAgICBjb25zdCBwcmVmaXhlcyA9IFsnV2Via2l0JywgJ01veicsICdtcycsICdPJywgJyddO1xuICAgIGxldCB0cmFuc2Zvcm1Qcm9wID0gJyc7XG5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHByZWZpeGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoYCR7cHJlZml4ZXNbaV19VHJhbnNmb3JtYCBpbiBzdHlsZSkge1xuICAgICAgICB0cmFuc2Zvcm1Qcm9wID0gcHJlZml4ZXNbaV07XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0cmFuc2Zvcm1Qcm9wICE9PSAnJyAmJiBgJHt0cmFuc2Zvcm1Qcm9wfVBlcnNwZWN0aXZlYCBpbiBzdHlsZSkge1xuICAgICAgcmV0dXJuICd0cmFuc2xhdGUzZCc7XG4gICAgfVxuICAgIGlmICh0cmFuc2Zvcm1Qcm9wICE9PSAnJykge1xuICAgICAgcmV0dXJuICd0cmFuc2xhdGUnO1xuICAgIH1cbiAgICByZXR1cm4gJ21hcmdpbic7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyB0aGUgQ1NTIGZvciB0aGUgcHJvZ3Jlc3MgYmFyIHBvc2l0aW9uIGJhc2VkIG9uIHRoZSBkZXRlY3RlZCBwb3NpdGlvbmluZyBzdHJhdGVneS5cbiAgICogRHluYW1pY2FsbHkgc2V0cyB0aGUgdHJhbnNmb3JtIG9yIG1hcmdpbi1sZWZ0IHByb3BlcnRpZXMgZm9yIHRoZSBiYXIncyBwb3NpdGlvbi5cbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IG4gLSBQb3NpdGlvbiB2YWx1ZSBvZiB0aGUgYmFyLCBhcyBhIG51bWJlciBiZXR3ZWVuIDAgYW5kIDEuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IC0gQ1NTIHN0eWxlcyBmb3IgdGhlIHByb2dyZXNzIGJhci5cbiAgICovXG4gIHByaXZhdGUgcmVhZG9ubHkgYmFyUG9zaXRpb25DU1MgPSAobjogbnVtYmVyKTogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9PiB7XG4gICAgY29uc3QgdHJhbnNmb3JtU3RyYXRlZ3kgPSB0aGlzLmdldFRyYW5zZm9ybVN0cmF0ZWd5KCk7XG4gICAgY29uc3QgYmFyUG9zaXRpb24gPSBgJHt0aGlzLnRvQmFyUGVyY2VudGFnZShuKX0lYDtcblxuICAgIGlmICh0cmFuc2Zvcm1TdHJhdGVneSA9PT0gJ3RyYW5zbGF0ZTNkJykge1xuICAgICAgcmV0dXJuIHsgdHJhbnNmb3JtOiBgdHJhbnNsYXRlM2QoJHtiYXJQb3NpdGlvbn0sMCwwKWAgfTtcbiAgICB9XG4gICAgaWYgKHRyYW5zZm9ybVN0cmF0ZWd5ID09PSAndHJhbnNsYXRlJykge1xuICAgICAgcmV0dXJuIHsgdHJhbnNmb3JtOiBgdHJhbnNsYXRlKCR7YmFyUG9zaXRpb259LDApYCB9O1xuICAgIH1cbiAgICByZXR1cm4geyBtYXJnaW5MZWZ0OiBiYXJQb3NpdGlvbiB9O1xuICB9O1xufVxuIl0sIm5hbWVzIjpbIlJlYWN0IiwiREVGQVVMVFMiLCJjb2xvciIsImluaXRpYWxQb3NpdGlvbiIsImhlaWdodCIsImVhc2luZyIsInNwZWVkIiwiekluZGV4Iiwic2hvd1NwaW5uZXIiLCJib3hTaGFkb3ciLCJpZ25vcmVTZWFyY2hQYXJhbXMiLCJkaXIiLCJTVEFSVF9IT0xZX0VWRU5UIiwiU1RPUF9IT0xZX0VWRU5UIiwidG9BYnNvbHV0ZVVSTCIsIl9fbmFtZSIsInVybCIsIlVSTCIsIndpbmRvdyIsImxvY2F0aW9uIiwiaHJlZiIsImlzU2FtZVBhZ2VBbmNob3IiLCJjdXJyZW50VXJsIiwibmV3VXJsIiwiY3VycmVudCIsIm5leHQiLCJzcGxpdCIsImlzU2FtZUhvc3QiLCJob3N0bmFtZSIsInJlcGxhY2UiLCJwYXJhbXNBcmVFcXVhbCIsInBhcmFtczEiLCJwYXJhbXMyIiwiQXJyYXkiLCJmcm9tIiwiZXZlcnkiLCJrZXkiLCJ2YWx1ZSIsImhhcyIsImdldCIsImhhc1NhbWVRdWVyeVBhcmFtZXRlcnMiLCJjdXJyZW50UGFyYW1zIiwiVVJMU2VhcmNoUGFyYW1zIiwic2VhcmNoIiwibmV4dFBhcmFtcyIsImlzU2FtZVBhdGhuYW1lIiwicGF0aG5hbWUiLCJjbGFtcCIsIm4iLCJtaW4iLCJtYXgiLCJNYXRoIiwicXVldWUiLCJwZW5kaW5nIiwiZm4iLCJzaGlmdCIsInB1c2giLCJsZW5ndGgiLCJyZXBhaW50RWxlbWVudCIsIm9iaiIsIm9mZnNldFdpZHRoIiwiX0hvbHlQcm9ncmVzcyIsImNvbnN0cnVjdG9yIiwiY3VzdG9tU2V0dGluZ3MiLCJzZXRUbyIsImlzU3RhcnRlZCIsInByb2dyZXNzTiIsInNldHRpbmdzIiwicHJvZ3Jlc3NCYXIiLCJnZXRPckNyZWF0ZUJhciIsImJhciIsIk9iamVjdCIsImFzc2lnbiIsInN0eWxlIiwiYmFyUG9zaXRpb25DU1MiLCJ0cmFuc2l0aW9uIiwib3BhY2l0eSIsInNldFRpbWVvdXQiLCJyZW1vdmVCYXJGcm9tRE9NIiwicmVtb3ZlU3Bpbm5lckZyb21ET00iLCJ0b0JhclBlcmNlbnRhZ2UiLCJzdGFydCIsInN0YXJ0VHJpY2tsZSIsImNyZWF0ZVNwaW5uZXIiLCJydW4iLCJpbmNyZW1lbnRTdGF0dXMiLCJjb21wbGV0ZSIsImNhbGN1bGF0ZUluY3JlbWVudCIsInN0YXR1cyIsImJhc2UiLCJzY2FsZSIsImV4cCIsImFtb3VudCIsImNyZWF0ZUJhciIsImZyb21TdGFydCIsIl9hIiwiX2IiLCJiYXJDb250YWluZXIiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJpZCIsInBvaW50ZXJFdmVudHMiLCJpbm5lckhUTUwiLCJxdWVyeVNlbGVjdG9yIiwicGVyY2VudGFnZSIsImJhY2tncm91bmQiLCJ0b1N0cmluZyIsInBvc2l0aW9uIiwid2lkdGgiLCJ0b3AiLCJsZWZ0IiwidHJhbnNmb3JtIiwiYm9keSIsImFwcGVuZENoaWxkIiwiZ2V0RWxlbWVudEJ5SWQiLCJzcGlubmVyIiwiZGlzcGxheSIsInJpZ2h0IiwiYm94U2l6aW5nIiwiYm9yZGVyIiwiYm9yZGVyVG9wQ29sb3IiLCJib3JkZXJMZWZ0Q29sb3IiLCJib3JkZXJSYWRpdXMiLCJhbmltYXRpb24iLCJrZXlmcmFtZXMiLCJyZW1vdmUiLCJnZXRUcmFuc2Zvcm1TdHJhdGVneSIsInByZWZpeGVzIiwidHJhbnNmb3JtUHJvcCIsImkiLCJ0cmFuc2Zvcm1TdHJhdGVneSIsImJhclBvc2l0aW9uIiwibWFyZ2luTGVmdCIsIl9fc3ByZWFkVmFsdWVzIiwiSG9seVByb2dyZXNzIiwic3RhcnRIb2x5TG9hZGVyIiwiZGlzcGF0Y2hFdmVudCIsIkV2ZW50Iiwic3RvcEhvbHlMb2FkZXIiLCJIb2x5TG9hZGVyIiwiaG9seVByb2dyZXNzUmVmIiwidXNlUmVmIiwidXNlRWZmZWN0Iiwic3RhcnRQcm9ncmVzcyIsImVycm9yIiwic3RvcFByb2dyZXNzIiwiaXNIaXN0b3J5UGF0Y2hlZCIsInN0b3BQcm9ncmVzc09uSGlzdG9yeVVwZGF0ZSIsIm9yaWdpbmFsUHVzaFN0YXRlIiwiaGlzdG9yeSIsInB1c2hTdGF0ZSIsImJpbmQiLCJhcmdzIiwib3JpZ2luYWxSZXBsYWNlU3RhdGUiLCJyZXBsYWNlU3RhdGUiLCJoYW5kbGVDbGljayIsImV2ZW50IiwidGFyZ2V0IiwiYW5jaG9yIiwiY2xvc2VzdCIsImhhc0F0dHJpYnV0ZSIsImN0cmxLZXkiLCJtZXRhS2V5Iiwic3RhcnRzV2l0aCIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwic3JjX2RlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/holy-loader/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/holy-loader/dist/index.js":
/*!************************************************!*\
  !*** ./node_modules/holy-loader/dist/index.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__),
/* harmony export */   startHolyLoader: () => (/* binding */ e0),
/* harmony export */   stopHolyLoader: () => (/* binding */ e1)
/* harmony export */ });
/* harmony import */ var next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/build/webpack/loaders/next-flight-loader/module-proxy */ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-flight-loader/module-proxy.js");

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`C:\Users\PMLS\Desktop\marketplace-hackathon-GIAIC\node_modules\holy-loader\dist\index.js#default`));

const e0 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`C:\Users\PMLS\Desktop\marketplace-hackathon-GIAIC\node_modules\holy-loader\dist\index.js#startHolyLoader`);

const e1 = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`C:\Users\PMLS\Desktop\marketplace-hackathon-GIAIC\node_modules\holy-loader\dist\index.js#stopHolyLoader`);


/***/ })

};
;